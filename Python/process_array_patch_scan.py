# DISCLAIMER: This script was partly generated using the GPT-5 AI model, thorough checks were done by the author before using any AI-generated routines.
# This script is meant for processing a patched scan dataset

import os
import json
import argparse
import numpy as np
import matplotlib.pyplot as plt


def load_array_dataset(npy_path):
    """
    Load the array dataset generated by the patch scanning routine

    Parameters
    ----------
    npy_path : str
        Path to the .npy file produced by the scan.

    Returns
    -------
    data : dict
        Dictionary with keys "frames", "timestamps", "positions",
        "x_centers", "z_centers", "settings" (settings may be overridden
        by the external JSON if present).
    """
    arr = np.load(npy_path, allow_pickle=True)
    if isinstance(arr, np.lib.npyio.NpzFile):
        raise ValueError("Expected a single .npy dict, got .npz instead.")
    data = arr.item()

    # Try to auto-load JSON settings if available
    base, _ = os.path.splitext(npy_path)
    json_path = base + "_settings.json"
    if os.path.exists(json_path):
        print(f"Found settings JSON: {json_path}")
        with open(json_path, "r") as f:
            json_settings = json.load(f)
        # Prefer JSON as the canonical settings (but keep original if needed)
        data["settings"] = json_settings
    else:
        print("No external JSON settings found, using settings from .npy only.")

    return data


def aggregate_frames(frames, mode="mean"):
    """
    Aggregate frames over sweeps and counts.

    Parameters
    ----------
    frames : np.ndarray
        Shape: (n_patches_x, n_patches_z, num_sweeps, num_counts, 8, 8).

    mode : {"mean", "sum", "max"}
        How to combine sweeps and counts.

    Returns
    -------
    patch_image : np.ndarray
        Shape: (n_patches_x, n_patches_z, 8, 8)
    """
    if frames.ndim != 6:
        raise ValueError(
            f"Expected frames with 6 dims "
            f"(n_px, n_pz, sweeps, counts, 8, 8), got {frames.shape}"
        )

    if mode == "mean":
        patch_image = frames.mean(axis=(2, 3))
    elif mode == "sum":
        patch_image = frames.sum(axis=(2, 3))
    elif mode == "max":
        patch_image = frames.max(axis=(2, 3))
    else:
        raise ValueError(f"Unknown aggregation mode: {mode}")

    return patch_image


def build_mosaic(patch_image, x_centers, z_centers, side_patch):
    """
    Build a spatially correct mosaic of all the acquired frames

    Parameters
    ----------
    patch_image : np.ndarray
        Shape: (n_patches_x, n_patches_z, 8, 8)

    x_centers : np.ndarray, shape (n_patches_x,)
    z_centers : np.ndarray, shape (n_patches_z,)

    side_patch : float
        Physical size of one patch.

    Returns
    -------
    mosaic : np.ndarray
        2D array, shape (n_patches_z * 8, n_patches_x * 8);
        first index -> Z, second index -> X (so imshow with origin='lower').

    extent : tuple
        (x_min, x_max, z_min, z_max) for imshow(extent=..., origin='lower').

    x_order, z_order : np.ndarray
        Indices used to sort patches by X and Z.
    """
    if patch_image.ndim != 4:
        raise ValueError(
            f"Expected patch_image with 4 dims "
            f"(n_px, n_pz, 8, 8), got {patch_image.shape}"
        )

    n_px, n_pz, h, w = patch_image.shape
    assert h == 8 and w == 8, "Expected 8x8 patches."

    x_centers = np.asarray(x_centers)
    z_centers = np.asarray(z_centers)

    x_order = np.argsort(x_centers)  # left -> right
    z_order = np.argsort(z_centers)  # bottom -> top (we'll use origin='lower')

    mosaic = np.zeros((n_pz * h, n_px * w), dtype=patch_image.dtype)

    for ix_out, ix in enumerate(x_order):
        for iz_out, iz in enumerate(z_order):
            patch = patch_image[ix, iz]  # shape (8, 8)
            row_start = iz_out * h
            row_end = (iz_out + 1) * h
            col_start = ix_out * w
            col_end = (ix_out + 1) * w
            mosaic[row_start:row_end, col_start:col_end] = patch

    x_min = x_centers.min() - side_patch / 2.0
    x_max = x_centers.max() + side_patch / 2.0
    z_min = z_centers.min() - side_patch / 2.0
    z_max = z_centers.max() + side_patch / 2.0

    extent = (x_min, x_max, z_min, z_max)
    return mosaic, extent, x_order, z_order


def save_mosaic_plot(mosaic, extent, out_path, title=None):
    """
    Save a figure of the mosaic
    """
    fig, ax = plt.subplots()
    im = ax.imshow(
        mosaic,
        extent=extent,
        origin="lower",
        aspect="equal",
    )
    cbar = fig.colorbar(im, ax=ax)
    cbar.set_label("Counts (cps)")

    ax.set_xlabel("x (mm)")
    ax.set_ylabel("z (mm)")
    if title is not None:
        ax.set_title(title)

    fig.tight_layout()
    fig.savefig(out_path, dpi=300)
    plt.close(fig)


def save_per_patch_plots(
    patch_image,
    x_centers,
    z_centers,
    x_order,
    z_order,
    out_dir,
    base_tag,
    cmap="viridis",
):
    """
    Save one figure per patch into out_dir.

    Parameters
    ----------
    patch_image : np.ndarray
        Shape (n_patches_x, n_patches_z, 8, 8) aggregated.

    x_centers, z_centers : 1D arrays
        Patch centers.

    x_order, z_order : 1D int arrays
        Order used in mosaic (np.argsort of centers).

    out_dir : str
        Directory where patch PNGs will be saved.

    base_tag : str
        Base name tag for files (e.g. npy file stem).

    cmap : str
        Matplotlib colormap name.
    """
    os.makedirs(out_dir, exist_ok=True)

    for ix_out, ix in enumerate(x_order):
        for iz_out, iz in enumerate(z_order):
            patch = patch_image[ix, iz]
            x_center = x_centers[ix]
            z_center = z_centers[iz]

            fig, ax = plt.subplots()
            im = ax.imshow(patch, origin="lower", aspect="equal", cmap=cmap)
            cbar = fig.colorbar(im, ax=ax)
            cbar.set_label("Reconstructed counts (cps)")

            ax.set_title(f"Widefield fluorescence scan")
            ax.set_xlabel("x (mm)")
            ax.set_ylabel("z (mm)")

            fig.tight_layout()

            fname = (
                f"{base_tag}_patch_ix{ix}_iz{iz}_"
                f"x{float(x_center):+0.4f}_z{float(z_center):+0.4f}.png"
            )
            fig.savefig(os.path.join(out_dir, fname), dpi=200)
            plt.close(fig)


def process_array_scan(
    npy_path,
    aggregate_mode="mean",
    cmap="viridis",
):
    """
    High-level function:

    - Loads dataset (and JSON settings if present)
    - Aggregates over sweeps/counts
    - Builds spatially correct X–Z mosaic
    - Saves:
        * full mosaic as PNG
        * per-patch PNGs

    All images go into one folder called 'OBIOS_patch_scan'
    next to the npy file.

    Parameters
    ----------
    npy_path : str
        Path to .npy file saved by acquisition script.

    aggregate_mode : {"mean", "sum", "max"}
        How to aggregate sweeps / counts per patch.

    cmap : str
        Colormap for per-patch plots (mosaic uses default colormap).
    """
    data = load_array_dataset(npy_path)
    frames = data["frames"]  # (n_px, n_pz, sweeps, counts, 8, 8)
    x_centers = data["x_centers"]
    z_centers = data["z_centers"]
    settings = data.get("settings", {})
    side_patch = float(settings["side_patch"])

    # Aggregate frames over sweeps and counts
    patch_image = aggregate_frames(frames, mode=aggregate_mode)

    # Build mosaic
    mosaic, extent, x_order, z_order = build_mosaic(
        patch_image, x_centers, z_centers, side_patch
    )

    # Output folder: array_patch_scan next to the npy file
    npy_dir = os.path.dirname(os.path.abspath(npy_path))
    out_dir = os.path.join(npy_dir, "array_patch_scan")
    os.makedirs(out_dir, exist_ok=True)

    base_name = os.path.splitext(os.path.basename(npy_path))[0]

    # Save mosaic image
    mosaic_path = os.path.join(out_dir, f"{base_name}_mosaic.png")
    title = (
        f"Patched widefield scan"
    )
    save_mosaic_plot(mosaic, extent, mosaic_path, title=title)
    print(f"Saved mosaic image to: {mosaic_path}")

    # Save per-patch images (into the same array_patch_scan folder)
    #save_per_patch_plots(
        #patch_image,
        #x_centers,
        #z_centers,
        #x_order,
        #z_order,
        #out_dir=out_dir,
        #base_tag=base_name,
        #cmap=cmap,
    #)
    #print(f"Saved per-patch images to folder: {out_dir}")

#Main function that executes the processing
def main():
    parser = argparse.ArgumentParser(
        description=(
            "Reconstruct array patch scan into a stitched x–z mosaic "
            "and per-patch images.\n\n"
            "All images are saved into a folder named 'array_patch_scan' "
            "next to the given .npy file.\n"
            "The script also automatically looks for a matching *_settings.json."
        )
    )
    parser.add_argument(
        "npy_path",
        help="Path to array_piezo_patch_scan_*.npy file.",
    )
    parser.add_argument(
        "--mode",
        choices=["mean", "sum", "max"],
        default="mean",
        help="Aggregation mode over sweeps and counts (default: mean).",
    )
    parser.add_argument(
        "--cmap",
        default="viridis",
        help="Colormap name for per-patch plots (default: viridis).",
    )

    args = parser.parse_args()
    process_array_scan(args.npy_path, aggregate_mode=args.mode, cmap=args.cmap)


if __name__ == "__main__":
    main()
